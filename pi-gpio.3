.\" Automatically generated by Pandoc 2.14.1
.\"
.TH "pi-gpio" "3" "10 Jun 2025" "pi-gpio 1.5" ""
.hy
.SH NAME
.PP
pi-gpio - A C library to manipulate Raspberry Pi GPIO.
.TP
Supports all production models available in September 2023 / all SOC
NOTE does not run on Pi5/BCM2712
.SH SYNOPSIS
.PP
#include <pi-gpio.h>
.PP
gcc -Wall -o prog prog.c -lpi-gpio
.SH DESCRIPTION
.PP
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[B]pi-gpio\f[R] is a C library for Raspberry Pi which allows control
of the General Purpose Input Output (GPIO) pins.
.PD 0
.P
.PD
\[en]
.PD 0
.P
.PD
\f[B]pi-sock\f[R] is a socket interface to the pi-gpio library.
.PP
Both expose the same functions (except setup functions) which are
described in this help file.
.PP
pi-sock allows access to all functions without \f[C]sudo\f[R] and allows
remote access.
.PD 0
.P
.PD
pi-sock does not support SPI
.SS Features
.PP
Read Raspberry Pi Information
.PP
Perform basic GPIO functions
.PD 0
.P
.PD
\[u2022] Set gpio as input or output
.PD 0
.P
.PD
\[u2022] Read/Write gpio
.PD 0
.P
.PD
\[u2022] Set pullup/down of gpio
.PD 0
.P
.PD
\[u2022] Read the current gpio mode
.PD 0
.P
.PD
\[u2022] Read gpio pull/up down (Pi4/BCM2711 only)
.PD 0
.P
.PD
\[u2022] Read/Write all GPIO in bank 0 in one operation
.PP
Software PWM on all pins
.PP
Hardware PWM support
.PP
Read/Set PAD drive, hysteresis & slew settings
.PP
PWM using kernel drivers
.PP
I\[S2]C using kernel drivers
.PP
SPI using kernel drivers
.SH OVERVIEW
.PP
.PD 0
.P
.PD
.SS Essential
.PP
setup - Initialise pi-gpio
.PP
cleanup - Clean\ up\ by\ releasing memory allocated by setup
.PP
\[en] OR \[en]
.PP
socket_connect - Connect to pi-gpio socket interface
.PP
socket_disconnect - Disconnect from socket interface
.SS Information
.PP
get_rpi_info - Raspberry Pi Information
.PP
get_revision - Raspberry Pi Revision Code
.SS GPIO
.PP
setup_gpio - Set gpio as an input or an output
.PP
input_gpio - Returns the GPIO level
.PP
output_gpio - Output to a GPIO channel
.PP
input_28 - Returns value of GPIO 0-27
.PP
output_28 - Sets value of GPIO 0-27
.PP
gpio_function - The current GPIO mode
.PP
get_pullupdn - The current GPIO pull/up down (Pi4 only)
.SS Software PWM
.PP
pwm_set_duty_cycle - Change\ the\ duty\ cycle
.PP
pwm_set_frequency - Change\ the\ frequency
.PP
pwm_start - Start\ software\ PWM
.PP
pwm_stop - Stop\ software\ PWM
.PP
pwm_exists - Check if there is a PWM for this gpio
.SS Hardware PWM
.PP
pwmSetGpio - Put gpio pin into PWM mode
.PP
pwmSetMode - Select the native \[lq]balanced\[rq] mode or standard
mark:space mode
.PP
pwmSetRange - Set the PWM range
.PP
pwmWrite - Set the PWM mark value (duty cycle = mark/range)
.PP
pwmSetDutycycle - Set the duty cycle (0.0 - 1.0)
.PP
pwmGetRange - Get the PWM range
.PP
pwmSetClock - Set/Change the PWM clock
.SS PAD
.PP
getPAD - Return\ the\ current\ PAD\ settings
.PP
setPAD - Set\ the\ PAD parameters
.SS kernel PWM
.PP
kpwm_export - Export PWM channel
.PP
kpwm_unexport - Unexport PWM channel
.PP
kpwm_get_period - get period
.PP
kpwm_enable - Enable/disable PWM on chan
.PP
kpwm_start - Enable the PWM on chan, setting period and pulse_width
.PP
kpwm_start_f - Enable the PWM on chan, setting frequency and duty_cycle
.PP
kpwm_set_pulse_width - Set pulse_width
.PP
kpwm_set_duty_cycle - Set duty_cycle
.SS I\[S2]C
.PP
See man pi-i2c
.SS SPI
.PP
See man pi-spi
.SS Extras
.PP
initialiseTimers - Initialise/reset timers
.PP
micros - Return a number of microseconds
.PP
millis - Return a number of milliseconds
.PP
.PD 0
.P
.PD
.SH FUNCTIONS
.PP
--------
.PD 0
.P
.PD
.SS Essential
.TP
\f[B]int setup(void)\f[R] - Initialise pi-gpio\[rs]
Must be called before any other function except \f[I]get_rpi_info\f[R],
\f[I]I\[S2]C\f[R] or \f[I]SPI\f[R] functions
.TP
\f[B]void cleanup(void)\f[R] - Clean\ up\ by\ releasing memory allocated by setup.
NOTE Does not reset\ GPIO\ that\ have\ been\ used.
.PP
\[en] OR \[en]
.PP
\f[B]int socket_connect(char* host)\f[R] - Connect to pi-gpio socket
interface
.PD 0
.P
.PD
\f[I]host\f[R]: IP address of host Pi with socket server
.PP
\f[B]void socket_disconnect(void)\f[R] - Disconnect from socket
interface
.SS Information
.PP
\f[B]int get_rpi_info(rpi_info *info)\f[R] - Raspberry Pi Information
.PD 0
.P
.PD
\f[I]Returns\f[R] typedef struct {
.PD 0
.P
.PD
int p1_revision; // P1 Header 0:None, 1:Pi B, 2:Pi B V2, 3:40 pin
.PD 0
.P
.PD
char *ram;
.PD 0
.P
.PD
char *manufacturer;
.PD 0
.P
.PD
char *processor;
.PD 0
.P
.PD
char *type;
.PD 0
.P
.PD
char revision[32];
.PD 0
.P
.PD
} rpi_info;
.PP
\f[B]unsigned get_revision(void)\f[R] - Raspberry Pi Revision Code
.PD 0
.P
.PD
\f[I]Returns\f[R] Raspberry Pi Revision Code
.SS GPIO
.PP
\f[B]NOTE\f[R] all gpio use Broadcom BCM numbers
.PP
\f[B]void setup_gpio(int gpio, int direction, int pud)\f[R] - Set gpio
as an input or an output
.PD 0
.P
.PD
\f[I]direction\f[R]: 0=IN, 1=OUT
.PD 0
.P
.PD
\f[I]pud\f[R]: 0=None 1=Up 2=Down
.PP
\f[B]int input_gpio(int gpio)\f[R] - Returns the GPIO level
.PD 0
.P
.PD
\f[I]Returns\f[R] HIGH=1=True or LOW=0=False
.PP
\f[B]void output_gpio(int gpio, int value)\f[R] - Output to a GPIO
channel
.PD 0
.P
.PD
\f[I]value\f[R] - 0/1 or False/True or LOW/HIGH
.PP
\f[B]int input_28(void)\f[R] - Returns value of GPIO 0-27
.PP
\f[B]void output_28(unsigned bits, unsigned mask)\f[R] - Sets value of
GPIO 0-27
.PD 0
.P
.PD
\f[I]bits\f[R]: 28 bit values to set; each bit 0/1
.PD 0
.P
.PD
\f[I]mask\f[R]: 28 bit mask specifying GPIO to set
.PP
\f[B]int gpio_function(int gpio)\f[R] - Returns the current GPIO mode
.PD 0
.P
.PD
\f[I]Returns\f[R] 0-7 (IN, OUT, ALT5, ALT4, ALT0, ALT1, ALT2, ALT3)
.PP
\f[B]int get_pullupdn(int gpio)\f[R] - Return the current GPIO pull
.PD 0
.P
.PD
\f[I]Returns\f[R]
.PD 0
.P
.PD
0:None/Unknown
.PD 0
.P
.PD
1:Up (Pi4 only)
.PD 0
.P
.PD
2:Down (Pi4 only)
.SS Software PWM
.PP
\f[B]void pwm_set_duty_cycle(unsigned int gpio, float dutycycle)\f[R] -
Change\ the\ duty\ cycle
.PD 0
.P
.PD
\f[I]dutycycle\f[R]:\ -\ between\ 0.0\ and\ 100.0
.PP
\f[B]void pwm_set_frequency(unsigned int gpio, float freq)\f[R] -
Change\ the\ frequency
.PD 0
.P
.PD
\f[I]frequency\f[R]:\ -\ frequency\ in\ Hz\ (freq\ >\ 1.0)
.PP
\f[B]void pwm_start(int gpio)\f[R] - Start\ software\ PWM
.PP
\f[B]void pwm_stop(int gpio)\f[R] - Stop\ software\ PWM
.PP
\f[B]int pwm_exists(unsigned int gpio)\f[R] - Check if there is a PWM
for this gpio
.PD 0
.P
.PD
Returns 1 if there is a PWM for this gpio
.SS Hardware PWM
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int pwmSetGpio(int gpio)\f[R] - Put gpio pin into PWM mode
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels, clocked at a fixed
frequency
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PP
\f[B]void pwmSetMode(int mode)\f[R] - Select the native
\[lq]balanced\[rq] mode or standard mark:space mode
.PD 0
.P
.PD
\f[I]mode\f[R] - 0 PWM_MODE_MS or 1 PWM_MODE_BAL
.PP
\f[B]int pwmSetRange(int gpio, unsigned int range)\f[R] - Set the PWM
range register
.PD 0
.P
.PD
\f[I]range\f[R]:
.PD 0
.P
.PD
In Mark:Space mode the output is HIGH for Mark time slots and LOW for
Range-Mark
.PD 0
.P
.PD
The output is thus a fixed frequency; PWM frequency = PWM clock / range
.PD 0
.P
.PD
Set initial duty cycle to 50% \f[I]Returns\f[R] 0 if successful
.PP
\f[B]int pwmWrite(int gpio, int value)\f[R] - Set the duty cycle
mark/range
.PD 0
.P
.PD
\f[I]value\f[R]: - 0-RANGE
.PP
\f[B]int pwmSetDutycycle(unsigned int gpio, float duty_cycle):\f[R] Set
the duty cycle
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: - 0.0-1.0
.PD 0
.P
.PD
\f[I]Returns\f[R] 0 if successful
.PP
\f[B]int pwmGetRange(int gpio)\f[R]: - Get the range
.PP
\f[B]void pwmSetClock(int divisor)\f[R] - Set/Change the PWM clock
.PD 0
.P
.PD
\f[I]divisor\f[R] - 1-4095
.PD 0
.P
.PD
Both channels share a common clock, which is Osc / divisor
.PD 0
.P
.PD
Osc is 19.2 MHz on most Pi models
.PD 0
.P
.PD
Osc is 54 MHz on BCM2711 used on Pi4
.SS PAD
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int getPAD(unsigned group)\f[R] -
Return\ the\ current\ PAD\ settings\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PP
\f[I]Returns\f[R]
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF
.PD 0
.P
.PD
slew = (padstate >> 4) & 1
.PD 0
.P
.PD
hyst = (padstate >> 3) & 1
.PD 0
.P
.PD
drive = padstate & 7
.PP
\f[B]void setPAD(unsigned group, unsigned padstate)\f[R] -
Set\ the\ PAD\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF : padstate = slew << 4 | hyst << 3 | drive
.SS kernel PWM
.TP
Hardware PWM module using the PWM kernel driver
The kernel PWM service needs to be started before use.
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PD 0
.P
.PD
.RS
.PP
To set up PWM on GPIO 18/19
.PD 0
.P
.PD
dtoverlay=pwm-2chan in config.txt
.PD 0
.P
.PD
sudo dtoverlay pwm-2chan on command line
.PP
To set up PWM on GPIO 12/13
.PD 0
.P
.PD
dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4
.PD 0
.P
.PD
sudo dtoverlay pwm-2chan pin=12 func=4 pin2=13 func2=4
.PP
There is a service pwm to set up a single channel.
.RE
.PP
\f[B]int kpwm_export(int chan)\f[R] - Export PWM channel
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PP
\f[B]int kpwm_unexport(unsigned chan)\f[R] - Unexport PWM channel
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]Returns\f[R] 0 if successful
.PP
\f[B]unsigned kpwm_get_period(unsigned chan)\f[R] - get period
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]Returns\f[R]: period in nanoseconds
.PP
\f[B]void kpwm_enable(unsigned chan, unsigned enable)\f[R] -
Enable/disable PWM on chan
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]enable\f[R]: 0 or 1
.PP
\f[B]void kpwm_start(unsigned chan, unsigned period, unsigned
pulse_width)\f[R] - Enable the PWM on chan, setting period and
pulse_width
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]period\f[R]: The period of the PWM signal in nanoseconds
.PD 0
.P
.PD
\f[I]pulse_width\f[R]: The period of the PWM signal in nanoseconds
.PP
\f[B]void kpwm_start_f(unsigned chan, float frequency, float
duty_cycle)\f[R] - Enable the PWM on chan, setting frequency and
duty_cycle
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]frequency\f[R]: The frequency of the PWM signal in Hz
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: 0.0 - 1.0
.PP
\f[B]void kpwm_set_pulse_width(unsigned chan, unsigned pulse_width)\f[R]
- Set pulse_width
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]pulse_width\f[R]: The period of the PWM signal in nanoseconds
.PP
\f[B]void kpwm_set_duty_cycle(unsigned chan, float duty_cycle)\f[R] -
Set duty_cycle
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: 0.0 - 1.0
.SS I\[S2]C
.PP
See man pi-i2c
.SS SPI
.PP
See man pi-spi
.SS Extras
.PP
\f[B]void initialiseTimers(void)\f[R] - Initialise/reset timers
.PP
\f[B]unsigned int micros(void)\f[R]
.PD 0
.P
.PD
Return a number of microseconds as an unsigned int
.PD 0
.P
.PD
Wraps after 71 minutes.
.PP
\f[B]unsigned int millis(void)\f[R]
.PD 0
.P
.PD
Return a number of milliseconds as an unsigned int
.PD 0
.P
.PD
Wraps at 49 days.
.SS Hardware PWM kernel driver
.PP
PWM module using the \f[I]pwm\f[R] kernel driver The Pi has 2
independent hardware PWM channels, clocked at a fixed frequency
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PD 0
.P
.PD
: PWM MUST be enabled BEFORE using this code, either in config.txt OR at
the command line
.PP
Name: pwm
.PP
Info: Configures a single PWM channel Legal pin,function combinations
for each channel:
.PD 0
.P
.PD
PWM0: 12,4(Alt0) 18,2(Alt5) 40,4(Alt0) 52,5(Alt1)
.PD 0
.P
.PD
PWM1: 13,4(Alt0) 19,2(Alt5) 41,4(Alt0) 45,4(Alt0) 53,5(Alt1)
.PD 0
.P
.PD
N.B.:
.PD 0
.P
.PD
1) Pin 18 is the only one available on all platforms, and
.PD 0
.P
.PD
it is the one used by the I2S audio interface.
.PD 0
.P
.PD
Pins 12 and 13 might be better choices on an A+, B+ or Pi2.
.PD 0
.P
.PD
2) The onboard analogue audio output uses both PWM channels.
.PD 0
.P
.PD
3) So be careful mixing audio and PWM.
.PD 0
.P
.PD
4) Currently the clock must have been enabled and configured
.PD 0
.P
.PD
by other means.
.PD 0
.P
.PD
.PP
Usage: dtoverlay=pwm,<param>=<val>
.PP
Params: pin Output pin (default 18) - see table
.PD 0
.P
.PD
func Pin function (default 2 = Alt5) - see above
.PD 0
.P
.PD
clock PWM clock frequency (informational)
.PP
sudo dtoverlay pwm/pwm-2chan <func=2>
.PD 0
.P
.PD
pwm Configures a single PWM channel
.PD 0
.P
.PD
pwm-2chan Configures both PWM channels (default GPIO12/13)
.PP
Info: Configures a single PWM channel Legal pin,function combinations
for each channel:
.PD 0
.P
.PD
PWM0: 12,4(Alt0) 18,2(Alt5) 40,4(Alt0) 52,5(Alt1)
.PD 0
.P
.PD
PWM1: 13,4(Alt0) 19,2(Alt5) 41,4(Alt0) 45,4(Alt0) 53,5(Alt1)
.PD 0
.P
.PD
N.B.:
.PD 0
.P
.PD
1) Pin 18 is the only one available on all platforms, and
.PD 0
.P
.PD
it is the one used by the I2S audio interface.
.PD 0
.P
.PD
Pins 12 and 13 might be better choices on an A+, B+ or Pi2.
.PD 0
.P
.PD
2) The onboard analogue audio output uses both PWM channels.
.PD 0
.P
.PD
.SH AUTHORS
Ian Binnie (Milliways).

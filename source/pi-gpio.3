.\" Automatically generated by Pandoc 2.14.1
.\"
.TH "pi-gpio" "3" "12 Dec 2022" "pi-gpio 1.1" ""
.hy
.SH NAME
.PP
pi-gpio - A C library to manipulate Raspberry Pi GPIO
.SH SYNOPSIS
.PP
#include <pi-gpio.h>
.PP
gcc -Wall -o prog prog.c -lpi-gpio
.SH DESCRIPTION
.PP
.PD 0
.P
.PD
.PD 0
.P
.PD
pi-gpio is a C library for Raspberry Pi which allows control of the
General Purpose Input Output (GPIO) pins
.PD 0
.P
.PD
.SS Features
.PP
-------
.PD 0
.P
.PD
.PP
.PD 0
.P
.PD
.PD 0
.P
.PD
.SH OVERVIEW
.PP
.PD 0
.P
.PD
.SS Essential
.PP
setup - Initialise pi-gpio
.PP
cleanup - Clean\ up\ by\ releasing memory allocated by setup
.SS Information
.PP
get_rpi_info - Raspberry Pi Information
.PP
get_revision - Raspberry Pi Revision Code
.SS GPIO
.PP
setup_gpio - Set gpio as an input or an output
.PP
input_gpio - Returns the GPIO level
.PP
output_gpio - Output to a GPIO channel
.PP
input_28 - Returns value of GPIO 0-27
.PP
output_28 - Sets value of GPIO 0-27
.PP
gpio_function - The current GPIO mode
.PP
get_pullupdn - The current GPIO pull/up down (Pi4 only)
.SS Software PWM
.PP
pwm_set_duty_cycle - Change\ the\ duty\ cycle
.PP
pwm_set_frequency - Change\ the\ frequency
.PP
pwm_start - Start\ software\ PWM
.PP
pwm_stop - Stop\ software\ PWM
.SS Hardware PWM
.PP
pwmSetGpio - Put gpio pin into PWM mode
.PP
pwmSetMode - Select the native \[lq]balanced\[rq] mode or standard
mark:space mode
.PP
pwmSetRange - Set the PWM range register
.PP
pwmSetClock - Set/Change the PWM clock
.PP
pwmWrite - Set the duty cycle mark/range
.SS PAD
.PP
getPAD - Return\ the\ current\ PAD\ settings
.PP
setPAD - Set\ the\ PAD parameters
.SS I\[S2]C
.PP
i2cOpen - Open I\[S2]C device
.PP
i2cRead - Read a single word (8 bits) from a device, without specifying
a register
.PP
i2cRead8 - Read a single word (8 bits) from register
.PP
i2cRead16 - Read a single word (16 bits) from register
.PP
i2cWrite - Write a single word (8 bits) to a device, without specifying
a register
.PP
i2cWrite8 - Write a single word (8 bits) to the specified register
.PP
i2cWrite16 - Write a single word (16 bits) to the specified register
.SS SPI
.PP
spiOpen - Initialise a SPI channel
.PP
spiDataRW2 - Write and Read a block of data over the SPI bus
.PP
spiDataRW - Write and Read a block of data over the SPI bus
.SS Extras
.PP
initialiseTimers - Initialise/reset timers
.PP
micros - Return a number of microseconds
.PP
millis - Return a number of milliseconds
.PP
.PD 0
.P
.PD
.SH FUNCTIONS
.PP
--------
.PD 0
.P
.PD
.SS Essential
.TP
\f[B]int setup(void)\f[R] - Initialise pi-gpio\[rs]
Must be called before any other function except \f[I]get_rpi_info\f[R],
\f[I]I\[S2]C\f[R] or \f[I]SPI\f[R] functions
.TP
\f[B]void cleanup(void)\f[R] - Clean\ up\ by\ releasing memory allocated by setup.
NOTE Does not reset\ GPIO\ that\ have\ been\ used.
.SS Information
.PP
\f[B]int get_rpi_info(rpi_info *info)\f[R] - Raspberry Pi Information
.PD 0
.P
.PD
\f[I]Returns\f[R] typedef struct {
.PD 0
.P
.PD
int p1_revision; // P1 Header 0:None, 1:Pi B, 2:Pi B V2, 3:40 pin
.PD 0
.P
.PD
char *ram;
.PD 0
.P
.PD
char *manufacturer;
.PD 0
.P
.PD
char *processor;
.PD 0
.P
.PD
char *type;
.PD 0
.P
.PD
char revision[1024];
.PD 0
.P
.PD
} rpi_info;
.PP
\f[B]unsigned get_revision(void)\f[R] - Raspberry Pi Revision Code
.PD 0
.P
.PD
\f[I]Returns\f[R] Raspberry Pi Revision Code
.SS GPIO
.PP
\f[B]NOTE\f[R] all gpio use Broadcom BCM numbers
.PP
\f[B]void setup_gpio(int gpio, int direction, int pud)\f[R] - Set gpio
as an input or an output
.PD 0
.P
.PD
\f[I]direction\f[R]: 0=IN, 1=OUT
.PD 0
.P
.PD
\f[I]pud\f[R]: 0=None 1=Up 2=Down
.PP
\f[B]int input_gpio(int gpio)\f[R] - Returns the GPIO level
.PD 0
.P
.PD
\f[I]Returns\f[R] HIGH=1=True or LOW=0=False
.PP
\f[B]void output_gpio(int gpio, int value)\f[R] - Output to a GPIO
channel
.PD 0
.P
.PD
\f[I]value\f[R] - 0/1 or False/True or LOW/HIGH
.PP
\f[B]int input_28(void)\f[R] - Returns value of GPIO 0-27
.PP
\f[B]void output_28(unsigned bits, unsigned mask)\f[R] - Sets value of
GPIO 0-27
.PD 0
.P
.PD
\f[I]bits\f[R]: 28 bit values to set; each bit 0/1
.PD 0
.P
.PD
\f[I]mask\f[R]: 28 bit mask specifying GPIO to set
.PP
\f[B]int gpio_function(int gpio)\f[R] - Returns the current GPIO mode
.PD 0
.P
.PD
\f[I]Returns\f[R] 0-7 (IN, OUT, ALT5, ALT4, ALT0, ALT1, ALT2, ALT3)
.PP
\f[B]int get_pullupdn(int gpio)\f[R] - Return the current GPIO pull
.PD 0
.P
.PD
\f[I]Returns\f[R]
.PD 0
.P
.PD
0:None/Unknown
.PD 0
.P
.PD
1:Up (Pi4 only)
.PD 0
.P
.PD
2:Down (Pi4 only)
.SS Software PWM
.PP
\f[B]void pwm_set_duty_cycle(unsigned int gpio, float dutycycle)\f[R] -
Change\ the\ duty\ cycle
.PD 0
.P
.PD
\f[I]dutycycle\f[R]:\ -\ between\ 0.0\ and\ 100.0
.PP
\f[B]void pwm_set_frequency(unsigned int gpio, float freq)\f[R] -
Change\ the\ frequency
.PD 0
.P
.PD
\f[I]frequency\f[R]:\ -\ frequency\ in\ Hz\ (freq\ >\ 1.0)
.PP
\f[B]void pwm_start(unsigned int gpio)\f[R] - Start\ software\ PWM
.PP
\f[B]void pwm_stop(unsigned int gpio)\f[R] - Stop\ software\ PWM
.SS Hardware PWM
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int pwmSetGpio(int gpio)\f[R] - Put gpio pin into PWM mode
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels, clocked at a fixed
frequency
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PP
\f[B]void pwmSetMode(int mode)\f[R] - Select the native
\[lq]balanced\[rq] mode or standard mark:space mode
.PD 0
.P
.PD
\f[I]mode\f[R] - 0 PWM_MODE_MS or 1 PWM_MODE_BAL
.PP
\f[B]int pwmSetRange(int gpio, unsigned int range)\f[R] - Set the PWM
range register
.PD 0
.P
.PD
\f[I]range\f[R]:
.PD 0
.P
.PD
In Mark:Space mode the output is HIGH for Mark time slots and LOW for
Range-Mark
.PD 0
.P
.PD
The output is thus a fixed frequency; PWM frequency = PWM clock / range
.PD 0
.P
.PD
Set initial duty cycle to 50%
.PP
\f[B]int pwmWrite(int gpio, int value)\f[R] - Set the duty cycle
mark/range
.PD 0
.P
.PD
\f[I]value\f[R]: - 0-RANGE
.PP
\f[B]void pwmSetClock(int divisor)\f[R] - Set/Change the PWM clock
.PD 0
.P
.PD
\f[I]divisor\f[R] - 1-4095
.PD 0
.P
.PD
Both channels share a common clock, which is Osc / divisor
.PD 0
.P
.PD
Osc is 19.2 MHz on most Pi models
.PD 0
.P
.PD
Osc is 54 MHz on BCM2711 used on Pi4
.SS PAD
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int getPAD(unsigned group)\f[R] -
Return\ the\ current\ PAD\ settings\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PP
\f[I]Returns\f[R]
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF
.PD 0
.P
.PD
slew = (padstate >> 4) & 1
.PD 0
.P
.PD
hyst = (padstate >> 3) & 1
.PD 0
.P
.PD
drive = padstate & 7
.PP
\f[B]void setPAD(unsigned group, unsigned padstate)\f[R] -
Set\ the\ PAD\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF : padstate = slew << 4 | hyst << 3 | drive
.SS I\[S2]C
.TP
I\[S2]C module using the I\[S2]C kernel driver
I\[S2]C MUST be enabled BEFORE using this code (see i2cOpen for detail)
.PP
\f[B]int i2cOpen(unsigned i2cBus, unsigned i2cAddr)\f[R] - Open I\[S2]C
device
.PD 0
.P
.PD
To enable I\[S2]C use \f[I]raspi-config\f[R]
.PD 0
.P
.PD
or ensure the line \f[I]dtparam=i2c_arm=on\f[R] or
\f[I]dtparam=i2c=on\f[R] is not commented out in
\f[I]/boot/config.txt\f[R]
.PD 0
.P
.PD
I\[S2]C can be enabled on the fly with a command e.g.\ \f[I]sudo dtparam
i2c\f[R]
.PD 0
.P
.PD
\f[B]NOTE\f[R] this will NOT return an error if there is no I\[S2]C
device at i2cAddr
.PD 0
.P
.PD
Use \f[I]i2cRead\f[R] etc.
to check
.PP
\f[I]i2cBus\f[R]: - 0-1
.PD 0
.P
.PD
\f[I]i2cAddr\f[R]: - 0-0x7F
.PP
\f[I]Returns\f[R] handle to the I\[S2]C device, or -1 on error
.PP
\f[B]int i2cRead(unsigned handle)\f[R] - Read a single word from a
device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PP
\f[I]Returns\f[R] word read
.PP
\f[B]int i2cRead8(unsigned handle, unsigned i2cReg)\f[R] - Read a single
word (8 bits) from register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PP
\f[I]Returns\f[R] word read
.PP
\f[B]int i2cRead16(unsigned handle, int i2cReg)\f[R] - Read a single
word (16 bits) from register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PP
\f[I]Returns\f[R] Word read
.PP
\f[B]int i2cWrite(unsigned handle, int data)\f[R] - Write a single word
(8 bits) to a device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite8(unsigned handle, int i2cReg, int value)\f[R] - Write
a single word (8 bits) to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite16(unsigned handle, int reg, int value)\f[R] - Write a
single word (16 bits) to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite(unsigned handle, int data)\f[R] - Write a single byte
to a device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite8(unsigned handle, int i2cReg, int value)\f[R] - Write
a single byte to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite16(unsigned handle, int reg, int value)\f[R] - Write a
single word to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.SS SPI
.TP
SPI module using the \f[I]spidev\f[R] kernel driver
SPI MUST be enabled BEFORE using this code (see spiOpen for detail)
.TP
\f[B]int spiOpen(unsigned controller, unsigned channel, unsigned speed, unsigned mode)\f[R] - Initialise a SPI channel
Raspberry Pi Zero, 1, 2 and 3 have three SPI controllers
.PD 0
.P
.PD
\f[B]SPI0\f[R], with 2 hardware chip selects, is available on all
Raspberry Pis
.PD 0
.P
.PD
To enable SPI0 use \f[I]raspi-config\f[R], or ensure the line
\f[I]dtparam=spi=on\f[R] is not commented out in
\f[I]/boot/config.txt\f[R]
.PD 0
.P
.PD
By default it uses 2 chip select lines, but this can be reduced to 1
using \f[I]dtoverlay=spi0-1cs\f[R]
.PD 0
.P
.PD
\f[B]SPI1\f[R], with 3 hardware chip selects, is available on all
Raspberry Pis with 40 pin header
mode 1,3 do not work!
.PD 0
.P
.PD
To enable SPI1 with 1, 2 or 3 chip select lines add to the
\f[I]/boot/config.txt\f[R] file
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-1cs\f[R] #1 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-2cs\f[R] #2 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-3cs\f[R] #3 chip select
.PD 0
.P
.PD
.PP
\f[B]SPI2\f[R], also with 3 hardware chip selects, is only available on
Compute Module 1, 3 and 3+
.PD 0
.P
.PD
On the Raspberry Pi 4, 400 and Compute Module 4 there are 4 additional
SPI buses:
.PD 0
.P
.PD
SPI3 to SPI6, each with 2 hardware chip selects
.PP
\f[I]controller\f[R]: - 0-6 (depending on model)
.PD 0
.P
.PD
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]speed\f[R]: - 500,000 through 32,000,000 - SPI clock speed in bps
.PD 0
.P
.PD
\f[I]mode\f[R]: - 0-3
.PP
\f[I]Returns\f[R] file-descriptor for the device, or -n on error
.TP
\f[B]int spiDataRW2(int channel, unsigned char *tx_data, unsigned char *rx_data, int len)\f[R] - Write and Read a block of data over the SPI bus
Discrete Tx/Rx buffers
.PD 0
.P
.PD
.PP
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]tx_data\f[R]: pointer to buffer containing transmit data
.PD 0
.P
.PD
\f[I]rx_data\f[R]: pointer to buffer to receive data
.PD 0
.P
.PD
\f[I]len\f[R]: length of buffer
.PP
\f[I]Returns\f[R] result code
.TP
\f[B]int spiDataRW (int channel, unsigned char *data, int len)\f[R] - Write and Read a block of data over the SPI bus
Shared Tx/Rx buffer
.PD 0
.P
.PD
.PP
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]data\f[R]: pointer to buffer containing transmit data (will be
overwritten by receive data)
.PD 0
.P
.PD
\f[I]len\f[R]: length of buffer
.PP
\f[I]Returns\f[R] result code
.SS Extras
.PP
\f[B]void initialiseTimers(void)\f[R] - Initialise/reset timers
.PP
\f[B]unsigned int micros(void)\f[R]
.PD 0
.P
.PD
Return a number of microseconds as an unsigned int
.PD 0
.P
.PD
Wraps after 71 minutes.
.PP
\f[B]unsigned int millis(void)\f[R]
.PD 0
.P
.PD
Return a number of milliseconds as an unsigned int
.PD 0
.P
.PD
Wraps at 49 days.
.SH AUTHORS
Ian Binnie (Milliways).

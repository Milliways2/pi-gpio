.\" Automatically generated by Pandoc 2.14.1
.\"
.TH "pi-gpio" "3" "29 Feb 2024" "pi-gpio 1.4" ""
.hy
.SH NAME
.PP
pi-gpio - A C library to manipulate Raspberry Pi GPIO.
.TP
Supports all production models available in September 2023 / all SOC
NOTE does not run on Pi5/BCM2712
.SH SYNOPSIS
.PP
#include <pi-gpio.h>
.PP
gcc -Wall -o prog prog.c -lpi-gpio
.SH DESCRIPTION
.PP
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[B]pi-gpio\f[R] is a C library for Raspberry Pi which allows control
of the General Purpose Input Output (GPIO) pins.
.PD 0
.P
.PD
\[en]
.PD 0
.P
.PD
\f[B]pi-sock\f[R] is a socket interface to the pi-gpio library.
.PP
Both expose the same functions (except setup functions) which are
described in this help file.
.PP
pi-sock allows access to all functions without \f[C]sudo\f[R] and allows
remote access.
.PD 0
.P
.PD
pi-sock does not support SPI
.SS Features
.PP
Read Raspberry Pi Information
.PP
Perform basic GPIO functions
.PD 0
.P
.PD
\[u2022] Set gpio as input or output
.PD 0
.P
.PD
\[u2022] Read/Write gpio
.PD 0
.P
.PD
\[u2022] Set pullup/down of gpio
.PD 0
.P
.PD
\[u2022] Read the current gpio mode
.PD 0
.P
.PD
\[u2022] Read gpio pull/up down (Pi4/BCM2711 only)
.PD 0
.P
.PD
\[u2022] Read/Write all GPIO in bank 0 in one operation
.PP
Software PWM on all pins
.PP
Hardware PWM support
.PP
Read/Set PAD drive, hysteresis & slew settings
.PP
PWM using kernel drivers
.PP
I\[S2]C using kernel drivers
.PP
SPI using kernel drivers
.SH OVERVIEW
.PP
.PD 0
.P
.PD
.SS Essential
.PP
setup - Initialise pi-gpio
.PP
cleanup - Clean\ up\ by\ releasing memory allocated by setup
.PP
\[en] OR \[en]
.PP
socket_connect - Connect to pi-gpio socket interface
.PP
socket_disconnect - Disconnect from socket interface
.SS Information
.PP
get_rpi_info - Raspberry Pi Information
.PP
get_revision - Raspberry Pi Revision Code
.SS GPIO
.PP
setup_gpio - Set gpio as an input or an output
.PP
input_gpio - Returns the GPIO level
.PP
output_gpio - Output to a GPIO channel
.PP
input_28 - Returns value of GPIO 0-27
.PP
output_28 - Sets value of GPIO 0-27
.PP
gpio_function - The current GPIO mode
.PP
get_pullupdn - The current GPIO pull/up down (Pi4 only)
.SS Software PWM
.PP
pwm_set_duty_cycle - Change\ the\ duty\ cycle
.PP
pwm_set_frequency - Change\ the\ frequency
.PP
pwm_start - Start\ software\ PWM
.PP
pwm_stop - Stop\ software\ PWM
.PP
pwm_exists - Check if there is a PWM for this gpio
.SS Hardware PWM
.PP
pwmSetGpio - Put gpio pin into PWM mode
.PP
pwmSetMode - Select the native \[lq]balanced\[rq] mode or standard
mark:space mode
.PP
pwmSetRange - Set the PWM range
.PP
pwmWrite - Set the PWM mark value (duty cycle = mark/range)
.PP
pwmSetDutycycle - Set the duty cycle (0.0 - 1.0)
.PP
pwmGetRange - Get the PWM range
.PP
pwmSetClock - Set/Change the PWM clock
.SS PAD
.PP
getPAD - Return\ the\ current\ PAD\ settings
.PP
setPAD - Set\ the\ PAD parameters
.SS kernel PWM
.PP
kpwm_export - Export PWM channel
.PP
kpwm_unexport - Unexport PWM channel
.PP
kpwm_get_period - get period
.PP
kpwm_enable - Enable/disable PWM on chan
.PP
kpwm_start - Enable the PWM on chan, setting period and pulse_width
.PP
kpwm_start_f - Enable the PWM on chan, setting frequency and duty_cycle
.PP
kpwm_set_pulse_width - Set pulse_width
.PP
kpwm_set_duty_cycle - Set duty_cycle
.SS I\[S2]C
.PP
i2cOpen - Open I\[S2]C device
.PP
i2cRead - Read a single word (8 bits) from a device, without specifying
a register
.PP
i2cRead8 - Read a single word (8 bits) from register
.PP
i2cRead16 - Read a single word (16 bits) from register
.PP
i2cWrite - Write a single word (8 bits) to a device, without specifying
a register
.PP
i2cWrite8 - Write a single word (8 bits) to the specified register
.PP
i2cWrite16 - Write a single word (16 bits) to the specified register
.SS SPI
.PP
spiOpen - Initialise a SPI channel
.PP
spiDataRW2 - Write and Read a block of data over the SPI bus
.PP
spiDataRW - Write and Read a block of data over the SPI bus
.SS Extras
.PP
initialiseTimers - Initialise/reset timers
.PP
micros - Return a number of microseconds
.PP
millis - Return a number of milliseconds
.PP
.PD 0
.P
.PD
.SH FUNCTIONS
.PP
--------
.PD 0
.P
.PD
.SS Essential
.TP
\f[B]int setup(void)\f[R] - Initialise pi-gpio\[rs]
Must be called before any other function except \f[I]get_rpi_info\f[R],
\f[I]I\[S2]C\f[R] or \f[I]SPI\f[R] functions
.TP
\f[B]void cleanup(void)\f[R] - Clean\ up\ by\ releasing memory allocated by setup.
NOTE Does not reset\ GPIO\ that\ have\ been\ used.
.PP
\[en] OR \[en]
.PP
\f[B]int socket_connect(char* host)\f[R] - Connect to pi-gpio socket
interface
.PD 0
.P
.PD
\f[I]host\f[R]: IP address of host Pi with socket server
.PP
\f[B]void socket_disconnect(void)\f[R] - Disconnect from socket
interface
.SS Information
.PP
\f[B]int get_rpi_info(rpi_info *info)\f[R] - Raspberry Pi Information
.PD 0
.P
.PD
\f[I]Returns\f[R] typedef struct {
.PD 0
.P
.PD
int p1_revision; // P1 Header 0:None, 1:Pi B, 2:Pi B V2, 3:40 pin
.PD 0
.P
.PD
char *ram;
.PD 0
.P
.PD
char *manufacturer;
.PD 0
.P
.PD
char *processor;
.PD 0
.P
.PD
char *type;
.PD 0
.P
.PD
char revision[32];
.PD 0
.P
.PD
} rpi_info;
.PP
\f[B]unsigned get_revision(void)\f[R] - Raspberry Pi Revision Code
.PD 0
.P
.PD
\f[I]Returns\f[R] Raspberry Pi Revision Code
.SS GPIO
.PP
\f[B]NOTE\f[R] all gpio use Broadcom BCM numbers
.PP
\f[B]void setup_gpio(int gpio, int direction, int pud)\f[R] - Set gpio
as an input or an output
.PD 0
.P
.PD
\f[I]direction\f[R]: 0=IN, 1=OUT
.PD 0
.P
.PD
\f[I]pud\f[R]: 0=None 1=Up 2=Down
.PP
\f[B]int input_gpio(int gpio)\f[R] - Returns the GPIO level
.PD 0
.P
.PD
\f[I]Returns\f[R] HIGH=1=True or LOW=0=False
.PP
\f[B]void output_gpio(int gpio, int value)\f[R] - Output to a GPIO
channel
.PD 0
.P
.PD
\f[I]value\f[R] - 0/1 or False/True or LOW/HIGH
.PP
\f[B]int input_28(void)\f[R] - Returns value of GPIO 0-27
.PP
\f[B]void output_28(unsigned bits, unsigned mask)\f[R] - Sets value of
GPIO 0-27
.PD 0
.P
.PD
\f[I]bits\f[R]: 28 bit values to set; each bit 0/1
.PD 0
.P
.PD
\f[I]mask\f[R]: 28 bit mask specifying GPIO to set
.PP
\f[B]int gpio_function(int gpio)\f[R] - Returns the current GPIO mode
.PD 0
.P
.PD
\f[I]Returns\f[R] 0-7 (IN, OUT, ALT5, ALT4, ALT0, ALT1, ALT2, ALT3)
.PP
\f[B]int get_pullupdn(int gpio)\f[R] - Return the current GPIO pull
.PD 0
.P
.PD
\f[I]Returns\f[R]
.PD 0
.P
.PD
0:None/Unknown
.PD 0
.P
.PD
1:Up (Pi4 only)
.PD 0
.P
.PD
2:Down (Pi4 only)
.SS Software PWM
.PP
\f[B]void pwm_set_duty_cycle(unsigned int gpio, float dutycycle)\f[R] -
Change\ the\ duty\ cycle
.PD 0
.P
.PD
\f[I]dutycycle\f[R]:\ -\ between\ 0.0\ and\ 100.0
.PP
\f[B]void pwm_set_frequency(unsigned int gpio, float freq)\f[R] -
Change\ the\ frequency
.PD 0
.P
.PD
\f[I]frequency\f[R]:\ -\ frequency\ in\ Hz\ (freq\ >\ 1.0)
.PP
\f[B]void pwm_start(int gpio)\f[R] - Start\ software\ PWM
.PP
\f[B]void pwm_stop(int gpio)\f[R] - Stop\ software\ PWM
.PP
\f[B]int pwm_exists(unsigned int gpio)\f[R] - Check if there is a PWM
for this gpio
.PD 0
.P
.PD
Returns 1 if there is a PWM for this gpio
.SS Hardware PWM
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int pwmSetGpio(int gpio)\f[R] - Put gpio pin into PWM mode
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels, clocked at a fixed
frequency
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PP
\f[B]void pwmSetMode(int mode)\f[R] - Select the native
\[lq]balanced\[rq] mode or standard mark:space mode
.PD 0
.P
.PD
\f[I]mode\f[R] - 0 PWM_MODE_MS or 1 PWM_MODE_BAL
.PP
\f[B]int pwmSetRange(int gpio, unsigned int range)\f[R] - Set the PWM
range register
.PD 0
.P
.PD
\f[I]range\f[R]:
.PD 0
.P
.PD
In Mark:Space mode the output is HIGH for Mark time slots and LOW for
Range-Mark
.PD 0
.P
.PD
The output is thus a fixed frequency; PWM frequency = PWM clock / range
.PD 0
.P
.PD
Set initial duty cycle to 50% \f[I]Returns\f[R] 0 if successful
.PP
\f[B]int pwmWrite(int gpio, int value)\f[R] - Set the duty cycle
mark/range
.PD 0
.P
.PD
\f[I]value\f[R]: - 0-RANGE
.PP
\f[B]int pwmSetDutycycle(unsigned int gpio, float duty_cycle):\f[R] Set
the duty cycle
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: - 0.0-1.0
.PD 0
.P
.PD
\f[I]Returns\f[R] 0 if successful
.PP
\f[B]int pwmGetRange(int gpio)\f[R]: - Get the range
.PP
\f[B]void pwmSetClock(int divisor)\f[R] - Set/Change the PWM clock
.PD 0
.P
.PD
\f[I]divisor\f[R] - 1-4095
.PD 0
.P
.PD
Both channels share a common clock, which is Osc / divisor
.PD 0
.P
.PD
Osc is 19.2 MHz on most Pi models
.PD 0
.P
.PD
Osc is 54 MHz on BCM2711 used on Pi4
.SS PAD
.PP
\f[B]NOTE\f[R] You need to be running as root to use these functions
.PP
\f[B]int getPAD(unsigned group)\f[R] -
Return\ the\ current\ PAD\ settings\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PP
\f[I]Returns\f[R]
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF
.PD 0
.P
.PD
slew = (padstate >> 4) & 1
.PD 0
.P
.PD
hyst = (padstate >> 3) & 1
.PD 0
.P
.PD
drive = padstate & 7
.PP
\f[B]void setPAD(unsigned group, unsigned padstate)\f[R] -
Set\ the\ PAD\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[R]:\ -\ 0-2
.PD 0
.P
.PD
\f[I]padstate\f[R]: - 0-0xF : padstate = slew << 4 | hyst << 3 | drive
.SS kernel PWM
.TP
Hardware PWM module using the PWM kernel driver
The kernel PWM service needs to be started before use.
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PD 0
.P
.PD
.RS
.PP
To set up PWM on GPIO 18/19
.PD 0
.P
.PD
dtoverlay=pwm-2chan in config.txt
.PD 0
.P
.PD
sudo dtoverlay pwm-2chan on command line
.PP
To set up PWM on GPIO 12/13
.PD 0
.P
.PD
dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4
.PD 0
.P
.PD
sudo dtoverlay pwm-2chan pin=12 func=4 pin2=13 func2=4
.PP
There is a service pwm to set up a single channel.
.RE
.PP
\f[B]int kpwm_export(int chan)\f[R] - Export PWM channel
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PP
\f[B]int kpwm_unexport(unsigned chan)\f[R] - Unexport PWM channel
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]Returns\f[R] 0 if successful
.PP
\f[B]unsigned kpwm_get_period(unsigned chan)\f[R] - get period
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]Returns\f[R]: period in nanoseconds
.PP
\f[B]void kpwm_enable(unsigned chan, unsigned enable)\f[R] -
Enable/disable PWM on chan
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]enable\f[R]: 0 or 1
.PP
\f[B]void kpwm_start(unsigned chan, unsigned period, unsigned
pulse_width)\f[R] - Enable the PWM on chan, setting period and
pulse_width
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]period\f[R]: The period of the PWM signal in nanoseconds
.PD 0
.P
.PD
\f[I]pulse_width\f[R]: The period of the PWM signal in nanoseconds
.PP
\f[B]void kpwm_start_f(unsigned chan, float frequency, float
duty_cycle)\f[R] - Enable the PWM on chan, setting frequency and
duty_cycle
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]frequency\f[R]: The frequency of the PWM signal in Hz
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: 0.0 - 1.0
.PP
\f[B]void kpwm_set_pulse_width(unsigned chan, unsigned pulse_width)\f[R]
- Set pulse_width
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]pulse_width\f[R]: The period of the PWM signal in nanoseconds
.PP
\f[B]void kpwm_set_duty_cycle(unsigned chan, float duty_cycle)\f[R] -
Set duty_cycle
.PD 0
.P
.PD
\f[I]chan\f[R]: 0 or 1
.PD 0
.P
.PD
\f[I]duty_cycle\f[R]: 0.0 - 1.0
.SS I\[S2]C
.TP
I\[S2]C module using the I\[S2]C kernel driver
I\[S2]C MUST be enabled BEFORE using this code (see i2cOpen for detail)
.PP
\f[B]int i2cOpen(unsigned i2cBus, unsigned i2cAddr)\f[R] - Open I\[S2]C
device
.PD 0
.P
.PD
To enable I\[S2]C use \f[I]raspi-config\f[R]
.PD 0
.P
.PD
or ensure the line \f[I]dtparam=i2c_arm=on\f[R] or
\f[I]dtparam=i2c=on\f[R] is not commented out in
\f[I]/boot/config.txt\f[R]
.PD 0
.P
.PD
I\[S2]C can be enabled on the fly with a command e.g.\ \f[I]sudo dtparam
i2c\f[R]
.PD 0
.P
.PD
\f[B]NOTE\f[R] this will NOT return an error if there is no I\[S2]C
device at i2cAddr
.PD 0
.P
.PD
Use \f[I]i2cRead\f[R] etc.
to check
.PP
\f[I]i2cBus\f[R]: - 0-1
.PD 0
.P
.PD
\f[I]i2cAddr\f[R]: - 0-0x7F
.PP
\f[I]Returns\f[R] handle to the I\[S2]C device, or -1 on error
.PP
\f[B]int i2cRead(unsigned handle)\f[R] - Read a single word from a
device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PP
\f[I]Returns\f[R] word read
.PP
\f[B]int i2cRead8(unsigned handle, unsigned i2cReg)\f[R] - Read a single
word (8 bits) from register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PP
\f[I]Returns\f[R] word read
.PP
\f[B]int i2cRead16(unsigned handle, int i2cReg)\f[R] - Read a single
word (16 bits) from register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PP
\f[I]Returns\f[R] Word read
.PP
\f[B]int i2cWrite(unsigned handle, int data)\f[R] - Write a single word
(8 bits) to a device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite8(unsigned handle, int i2cReg, int value)\f[R] - Write
a single word (8 bits) to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite16(unsigned handle, int reg, int value)\f[R] - Write a
single word (16 bits) to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite(unsigned handle, int data)\f[R] - Write a single byte
to a device, without specifying a register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite8(unsigned handle, int i2cReg, int value)\f[R] - Write
a single byte to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - byte to write
.PP
\f[I]Returns\f[R] result code
.PP
\f[B]int i2cWrite16(unsigned handle, int reg, int value)\f[R] - Write a
single word to the specified register
.PD 0
.P
.PD
\f[I]handle\f[R]: - handle to the I\[S2]C device
.PD 0
.P
.PD
\f[I]i2cReg\f[R]: - I\[S2]C register
.PD 0
.P
.PD
\f[I]data\f[R]: - word to write
.PP
\f[I]Returns\f[R] result code
.SS SPI
.TP
SPI module using the \f[I]spidev\f[R] kernel driver
SPI MUST be enabled BEFORE using this code (see spiOpen for detail)
.TP
\f[B]int spiOpen(unsigned controller, unsigned channel, unsigned speed, unsigned mode)\f[R] - Initialise a SPI channel
Raspberry Pi Zero, 1, 2 and 3 have three SPI controllers
.PD 0
.P
.PD
\f[B]SPI0\f[R], with 2 hardware chip selects, is available on all
Raspberry Pis
.PD 0
.P
.PD
To enable SPI0 use \f[I]raspi-config\f[R], or ensure the line
\f[I]dtparam=spi=on\f[R] is not commented out in
\f[I]/boot/config.txt\f[R]
.PD 0
.P
.PD
By default it uses 2 chip select lines, but this can be reduced to 1
using \f[I]dtoverlay=spi0-1cs\f[R]
.PD 0
.P
.PD
\f[B]SPI1\f[R], with 3 hardware chip selects, is available on all
Raspberry Pis with 40 pin header
mode 1,3 do not work!
.PD 0
.P
.PD
To enable SPI1 with 1, 2 or 3 chip select lines add to the
\f[I]/boot/config.txt\f[R] file
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-1cs\f[R] #1 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-2cs\f[R] #2 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-3cs\f[R] #3 chip select
.PD 0
.P
.PD
.PP
\f[B]SPI2\f[R], also with 3 hardware chip selects, is only available on
Compute Module 1, 3 and 3+
.PD 0
.P
.PD
On the Raspberry Pi 4, 400 and Compute Module 4 there are 4 additional
SPI buses:
.PD 0
.P
.PD
SPI3 to SPI6, each with 2 hardware chip selects
.PP
\f[I]controller\f[R]: - 0-6 (depending on model)
.PD 0
.P
.PD
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]speed\f[R]: - 500,000 through 32,000,000 - SPI clock speed in bps
.PD 0
.P
.PD
\f[I]mode\f[R]: - 0-3
.PP
\f[I]Returns\f[R] file-descriptor for the device, or -n on error
.TP
\f[B]int spiDataRW2(int channel, unsigned char *tx_data, unsigned char *rx_data, int len)\f[R] - Write and Read a block of data over the SPI bus
Discrete Tx/Rx buffers
.PD 0
.P
.PD
.PP
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]tx_data\f[R]: pointer to buffer containing transmit data
.PD 0
.P
.PD
\f[I]rx_data\f[R]: pointer to buffer to receive data
.PD 0
.P
.PD
\f[I]len\f[R]: length of buffer
.PP
\f[I]Returns\f[R] result code
.TP
\f[B]int spiDataRW (int channel, unsigned char *data, int len)\f[R] - Write and Read a block of data over the SPI bus
Shared Tx/Rx buffer
.PD 0
.P
.PD
.PP
\f[I]channel\f[R]: - 0-3 (depending on available chip selects)
.PD 0
.P
.PD
\f[I]data\f[R]: pointer to buffer containing transmit data (will be
overwritten by receive data)
.PD 0
.P
.PD
\f[I]len\f[R]: length of buffer
.PP
\f[I]Returns\f[R] result code
.SS Extras
.PP
\f[B]void initialiseTimers(void)\f[R] - Initialise/reset timers
.PP
\f[B]unsigned int micros(void)\f[R]
.PD 0
.P
.PD
Return a number of microseconds as an unsigned int
.PD 0
.P
.PD
Wraps after 71 minutes.
.PP
\f[B]unsigned int millis(void)\f[R]
.PD 0
.P
.PD
Return a number of milliseconds as an unsigned int
.PD 0
.P
.PD
Wraps at 49 days.
.SS Hardware PWM kernel driver
.PP
PWM module using the \f[I]pwm\f[R] kernel driver The Pi has 2
independent hardware PWM channels, clocked at a fixed frequency
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53 : PWM MUST be
enabled BEFORE using this code, either in config.txt OR at the command
line
.PP
Name: pwm
.PP
Info: Configures a single PWM channel Legal pin,function combinations
for each channel: PWM0: 12,4(Alt0) 18,2(Alt5) 40,4(Alt0) 52,5(Alt1)
PWM1: 13,4(Alt0) 19,2(Alt5) 41,4(Alt0) 45,4(Alt0) 53,5(Alt1) N.B.: 1)
Pin 18 is the only one available on all platforms, and it is the one
used by the I2S audio interface.
Pins 12 and 13 might be better choices on an A+, B+ or Pi2.
2) The onboard analogue audio output uses both PWM channels.
3) So be careful mixing audio and PWM.
4) Currently the clock must have been enabled and configured by other
means.
.PP
Usage: dtoverlay=pwm,=
.PP
Params: pin Output pin (default 18) - see table func Pin function
(default 2 = Alt5) - see above clock PWM clock frequency (informational)
.PP
sudo dtoverlay pwm/pwm-2chan <func=2> pwm Configures a single PWM
channel pwm-2chan Configures both PWM channels (default GPIO12/13)
.PP
Info: Configures a single PWM channel Legal pin,function combinations
for each channel: PWM0: 12,4(Alt0) 18,2(Alt5) 40,4(Alt0) 52,5(Alt1)
PWM1: 13,4(Alt0) 19,2(Alt5) 41,4(Alt0) 45,4(Alt0) 53,5(Alt1) N.B.: 1)
Pin 18 is the only one available on all platforms, and it is the one
used by the I2S audio interface.
Pins 12 and 13 might be better choices on an A+, B+ or Pi2.
2) The onboard analogue audio output uses both PWM channels.
.SS SPI
.TP
\f[B]int spiOpen(unsigned controller, unsigned channel, unsigned speed, unsigned mode)\f[R] - Initialise a SPI channel
Raspberry Pi Zero, 1, 2 and 3 have three SPI controllers
.PD 0
.P
.PD
\f[B]SPI0\f[R], with 2 hardware chip selects, is available on all
Raspberry Pis
.PD 0
.P
.PD
To enable SPI0 use \f[I]raspi-config\f[R], or ensure the line
\f[I]dtparam=spi=on\f[R] is not commented out in
\f[I]/boot/config.txt\f[R]
.PD 0
.P
.PD
By default it uses 2 chip select lines, but this can be reduced to 1
using \f[I]dtoverlay=spi0-1cs\f[R]
.PD 0
.P
.PD
\f[B]SPI1\f[R], with 3 hardware chip selects, is available on all
Raspberry Pis with 40 pin header
mode 1,3 do not work!
.PD 0
.P
.PD
To enable SPI1 with 1, 2 or 3 chip select lines add to the
\f[I]/boot/config.txt\f[R] file
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-1cs\f[R] #1 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-2cs\f[R] #2 chip select
.PD 0
.P
.PD
\f[I]dtoverlay=spi1-3cs\f[R] #3 chip select
.PD 0
.P
.PD
.SH AUTHORS
Ian Binnie (Milliways).

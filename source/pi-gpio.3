.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "pi-gpio" "3" "15 Oct 2021" "pi-gpio 0.7.2" ""
.hy
.SH NAME
.PP
pi-gpio \- A C library to manipulate Raspberry Pi GPIO
.SH SYNOPSIS
.PP
#include <pi-gpio.h>
.PP
gcc \-Wall \-o prog prog.c \-lpi-gpio
.SH DESCRIPTION
.PP
.PD 0
.P
.PD
.PD 0
.P
.PD
pi-gpio is a C library for Raspberry Pi which allows control of the
General Purpose Input Output (GPIO) pins.
.PD 0
.P
.PD
.SS Features
.PP
\-\-\-\-\-\-\-\-
.PD 0
.P
.PD
.SH OVERVIEW
.PP
.PD 0
.P
.PD
.SS Essential
.PP
setup \- Initialise pi-gpio
.PP
cleanup \- Clean\ up\ by\ releasing memory allocated by setup
.SS Information
.PP
get_rpi_info \- Raspberry Pi Information
.SS GPIO
.PP
setup_gpio \- Set gpio as an input or an output
.PP
input_gpio \- Returns the GPIO level
.PP
output_gpio \- Output to a GPIO channel
.PP
gpio_function \- The current GPIO mode
.PP
get_pullupdn \- The current GPIO pull/up down (Pi4 only)
.SS Software PWM
.PP
pwm_set_duty_cycle \- Change\ the\ duty\ cycle
.PP
pwm_set_frequency \- Change\ the\ frequency
.PP
pwm_start \- Start\ software\ PWM
.PP
pwm_stop \- Stop\ software\ PWM
.SS Hardware PWM
.PP
pwmSetGpio \- Put gpio pin into PWM mode
.PP
pwmSetMode \- Select the native \[lq]balanced\[rq] mode or standard
mark:space mode
.PP
pwmSetRange \- Set the PWM range register
.PP
pwmSetClock \- Set/Change the PWM clock
.PP
pwmWrite \- Set the duty cycle mark/range
.SS PAD
.PP
getPAD \- Return\ the\ current\ PAD\ settings
.PP
setPAD \- Set\ the\ PAD parameters
.SS Extras
.PP
initialiseTimers \- Initialise/reset timers
.PP
micros \- Return a number of microseconds
.PP
millis \- Return a number of milliseconds
.PP
.PD 0
.P
.PD
.SH FUNCTIONS
.PP
\-
.PD 0
.P
.PD
.SS Essential
.TP
.B \f[B]int setup(void)\f[] \- Initialise pi-gpio.
Must be called before any other function except \f[I]get_rpi_info\f[].
.RS
.RE
.TP
.B \f[B]void cleanup(void)\f[] \- Clean\ up\ by\ releasing memory allocated by setup.
NOTE Does not reset\ GPIO\ that\ have\ been\ used.
.RS
.RE
.SS Information
.PP
\f[B]int get_rpi_info(rpi_info *info)\f[] \- Raspberry Pi Information.
.PD 0
.P
.PD
Returns typedef struct {
.PD 0
.P
.PD
int p1_revision; // P1 Header 0:None, 1:Pi B, 2:Pi B V2, 3:40 pin
.PD 0
.P
.PD
char *ram;
.PD 0
.P
.PD
char *manufacturer;
.PD 0
.P
.PD
char *processor;
.PD 0
.P
.PD
char *type;
.PD 0
.P
.PD
char revision[1024];
.PD 0
.P
.PD
} rpi_info;
.PP
.PD 0
.P
.PD
.SS GPIO
.PP
\f[B]NOTE\f[] all gpio use Broadcom BCM numbers.
.PP
\f[B]void setup_gpio(int gpio, int direction, int pud)\f[] \- Set gpio
as an input or an output
.PD 0
.P
.PD
\f[I]direction\f[]: 0=IN, 1=OUT
.PD 0
.P
.PD
\f[I]pud\f[]: 0=None 1=Up 2=Down
.PP
\f[B]int input_gpio(int gpio)\f[] \- Returns the GPIO level.
.PD 0
.P
.PD
Returns HIGH=1=True or LOW=0=False
.PP
\f[B]void output_gpio(int gpio, int value)\f[] \- Output to a GPIO
channel
.PD 0
.P
.PD
\f[I]value\f[] \- 0/1 or False/True or LOW/HIGH
.PP
\f[B]int gpio_function(int gpio)\f[] \- Returns the current GPIO mode
.PD 0
.P
.PD
Returns 0\-7 (IN, OUT, ALT5, ALT4, ALT0, ALT1, ALT2, ALT3)
.PP
\f[B]int get_pullupdn(int gpio)\f[] \- Return the current GPIO pull
.PD 0
.P
.PD
Returns
.PD 0
.P
.PD
0:None/Unknown
.PD 0
.P
.PD
1:Up Pi4 only
.PD 0
.P
.PD
2:Down Pi4 only
.SS Software PWM
.PP
\f[B]void pwm_set_duty_cycle(unsigned int gpio, float dutycycle)\f[] \-
Change\ the\ duty\ cycle
.PD 0
.P
.PD
\f[I]dutycycle\f[]:\ \-\ between\ 0.0\ and\ 100.0
.PP
\f[B]void pwm_set_frequency(unsigned int gpio, float freq)\f[] \-
Change\ the\ frequency
.PD 0
.P
.PD
\f[I]frequency\f[]:\ \-\ frequency\ in\ Hz\ (freq\ >\ 1.0)
.PP
\f[B]void pwm_start(unsigned int gpio)\f[] \- Start\ software\ PWM
.PP
\f[B]void pwm_stop(unsigned int gpio)\f[] \- Stop\ software\ PWM
.SS Hardware PWM
.PP
\f[B]NOTE\f[] You need to be running as root to use these functions.
.PP
\f[B]int pwmSetGpio(int gpio)\f[] \- Put gpio pin into PWM mode
.PD 0
.P
.PD
The Pi has 2 independent hardware PWM channels, clocked at a fixed
frequency.
.PD 0
.P
.PD
The same PWM channel is available on multiple pins but the output is
identical.
.PD 0
.P
.PD
Channel 0 can be accessed on GPIO 12, 18, 40, 52
.PD 0
.P
.PD
Channel 1 can be accessed on GPIO 13, 19, 41, 45, 53
.PP
\f[B]void pwmSetMode(int mode)\f[] \- Select the native
\[lq]balanced\[rq] mode or standard mark:space mode
.PD 0
.P
.PD
\f[I]mode\f[] \- 0 PWM_MODE_MS or 1 PWM_MODE_BAL
.PP
\f[B]int pwmSetRange(int gpio, unsigned int range)\f[] \- Set the PWM
range register
.PD 0
.P
.PD
\f[I]range\f[]:
.PD 0
.P
.PD
In Mark:Space mode the output is HIGH for Mark time slots and LOW for
Range\-Mark
.PD 0
.P
.PD
The output is thus a fixed frequency; PWM frequency = PWM clock / range
.PD 0
.P
.PD
Set initial duty cycle to 50%
.PP
\f[B]int pwmWrite(int gpio, int value)\f[] \- Set the duty cycle
mark/range
.PD 0
.P
.PD
\f[I]value\f[]: \- 0\-RANGE
.PP
\f[B]void pwmSetClock(int divisor)\f[] \- Set/Change the PWM clock
.PD 0
.P
.PD
\f[I]divisor\f[] \- 1\-4095
.PD 0
.P
.PD
Both channels share a common clock, which is Osc / divisor
.PD 0
.P
.PD
Osc is 19.2 MHz on most Pi models
.PD 0
.P
.PD
Osc is 54 MHz on BCM2711 used on Pi4
.SS PAD
.PP
\f[B]NOTE\f[] You need to be running as root to use these functions.
.PP
\f[B]int getPAD(unsigned group)\f[] \-
Return\ the\ current\ PAD\ settings\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[]:\ \-\ 0\-2
.PD 0
.P
.PD
Returns
.PD 0
.P
.PD
\f[I]padstate\f[]: \- 0\-0xF
.PD 0
.P
.PD
slew = (padstate >> 4) & 1
.PD 0
.P
.PD
hyst = (padstate >> 3) & 1
.PD 0
.P
.PD
drive = padstate & 7
.PP
\f[B]void setPAD(unsigned group, unsigned padstate)\f[] \-
Set\ the\ PAD\ (slew,\ hyst,\ drive)
.PD 0
.P
.PD
\f[I]group\f[]:\ \-\ 0\-2
.PD 0
.P
.PD
\f[I]padstate\f[]: \- 0\-0xF
.PD 0
.P
.PD
padstate = slew << 4 | hyst << 3 | drive
.SS Extras
.PP
\f[B]void initialiseTimers(void)\f[] \- Initialise/reset timers
.PP
\f[B]unsigned int micros(void)\f[]
.PD 0
.P
.PD
Return a number of microseconds as an unsigned int
.PD 0
.P
.PD
Wraps after 71 minutes.
.PP
\f[B]unsigned int millis(void)\f[]
.PD 0
.P
.PD
Return a number of milliseconds as an unsigned int
.PD 0
.P
.PD
Wraps at 49 days.
.SH AUTHORS
Ian Binnie (Milliways).
